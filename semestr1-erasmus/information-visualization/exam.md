# Exam

## Visualization

- InfoVis × SciVis × DataVis
	- InfoVis – use of computer-supported, interactive visual representations of data to amplify cognition
	- SciVis – datasets have a given spatialisation
	- DataVis – web-based, communication
	- challenges: diversity, scale
- visual information-seeking mantra (Ben Shneiderman)
	- overview first
	- zoom and filter
	- details on demand
- visual perception is a two stage process
	- parallel extraction of low-level properties … retina
	- sequential goal-directed processing … brain
- Gestalt psychology
	- one stimulus, two perceptions
	- there is a difference between stimulus and perception
	- emergence – we need to see the whole picture, not just parts
	- reification – perception contains more spatial information than the stimulus
	- multistability – ambiguous stimuli can generate different perceptions but they cannot coexist simultaneously
	- invariance – objects are recognized independently of various variations (transformations, lightning, …)
	- laws of grouping – law level perceptions are grouped into higher-level objects
		- good Gestalt
- information visualization pipeline
	- source data → data tables
		- data transformations
	- data tables → visual abstraction
		- visual mappings
		- transition from data form to visual form
		- we use data attributes to create (visual) marks
	- visual abstraction → views
		- view transformations
		- result … actual pixels
- taxonomies of data types
	- “what comparisons can I make?”
	- “how can I aggregate the data?”
	- nominal … only equality (=)
		- aggregation: mode (we show the most frequent one) or top-k
			- if we have a taxonomy (hierarchy), we can group the data
		- examples: city of birth, university, handedness
	- ordered … ordering and equality (<, =)
		- aggregation: median, quantiles, histogram (count per bucket)
		- examples: education level, feedback scale
	- quantitative … “how much smaller is it?”
		- → intervals … $v-v'$
			- examples: shoe size, pH scale
		- → ratios … $v/v'$
			- only if there is a meaningful zero on the scale
			- examples: duration, cost
		- aggregation: mean, std dev, skew
- properties of visual channels
	- association $(\equiv)$
		- does the visual channel play well with the other visual channels?
		- size and value don't provide association (they impact perception of other visual variables) – the other visual variables are more difficult to see for smaller sizes / lighter marks
	- selection $(\neq)$
		- can you focus on a specific subset in this visual channel?
		- color provides selection
	- order $(O)$
		- items can be ordered according to this variable, without relying on a lookup to a legend
	- quantity $(Q)$
		- the difference between two items can be quantified
- channels (according to Bertin)
	- position $(\equiv,\neq,O,Q)$
	- size $(\neq,O,Q)$
		- beware: for quantity judgement, our perception is biased
			- Stevens' Law: $\frac{p(x_1)}{p(x_0)}=\left(\frac{x_1}{x_0}\right)^\beta$
			- $p$ … perception
			- $\beta$ is different for length, area, and volume
			- in 2D, we underestimate large sizes (in 3D it's even worse)
		- note on depth
			- depth is perceived mainly because it impacts size
			- using the third dimension introduces ambiguity: is it small or is it far away?
			- but we can keep all the objects the same size and only apply motion parallax & skew instead of perspective
	- value $(\neq,O)$
		- lightness of color
		- light marks are harder to see
	- texture $(\equiv,\neq,O)$
		- usually black and white (dark and light color) – we can mix it with color channel
		- probably underused
	- color $(\equiv,\neq)$
		- we don't perceive the axis of wavelengths
		- colors are usually used as labels
	- orientation $(\equiv,\neq)$
		- only for some shapes (not circles)
	- shape $(\equiv)$
		- does not provide selection → it's better to use color for grouping
- Mackinlay: suitability of variables, possible combinations
	- distinguishes more visual channels
	- ordered lists – the best channels on top
	- systematic approach to choosing visual channels
	- position is the best visual channel
- Card & Mackinlay table
	- Variable – name of the variable
	- D (data type)
		- N (nominal)
		- O (ordinal)
		- Q (quantitative)
		- QX, QY (quantitative and intrinsically spatial)
		- QXlon, QYlat (geographical)
	- X, Y, Z, T (position in space and time)
		- P (point)
		- L (line)
		- A (area)
	- R (retinal encoding)
		- C (color)
		- S (size)
	- — (connection)
	- \[] (enclosure)
	- CP (control processing)
		- text
- interesting visualizations
	- multi-dimensional data
		- scatter plot matrix
		- parallel coordinates
	- time series
		- horizon graph – example of composite visual mapping (one attribute → multiple graphic variables)
- interaction
	- ScatterDice – choosing axes for the graph
	- Zoomable Treemaps
		- treemap of the internet
		- large collections are divided by initial numbers
		- clicking zooms by one level
		- but I can also draw a stroke → it zooms to the smallest node which contains the whole stroke
		- sometimes, the animation is controlled by the interaction
	- when interacting directly with the visualization (not through “external” controls), we need to project from the screen space to the data space
- similarity
	- we need a measure of similarity for two items and for two groups
	- dendrogram – tree representing the similarity of items
		- the lower is the common ancestor of the items, the more similar they are
		- we can cut the dendrogram at some level to get clustering
	- we can use dots in matrix to visualize similarity (the larger the dot, the more similar the items are)
		-  we can reorder the items to minimize differences between neighbors
		- that way, we get clusters
		- the matrix is symmetrical so we only need one half → [Dendrogramix](https://iihm.imag.fr/publication/BDB15a/)
			- we can see relations that would disappear in the dendrogram
			- the app supports dragging items
				- if the feedback is continuous, we can track the changes
- NodeTrix – hybrid visualization of graphs
	- how to express graphs traditionally
		- diagram – chaotic for large graphs
		- adjacency matrix – difficult to find longer paths
	- NodeTrix combines both approaches
	- social network
		- few nodes with a lot of connections (a lot of nodes with few connections)
		- adjacency matrix is useful to see if some nodes form a clique

## Networks

- graph, network: definitions, metrics, tasks
	 - graph = vertices, edges (can be directed)
	 - network = graph with attributes on the vertices and/or the edges
	 - graph theory provides metrics
		 - vertices – degree, centrality
		 - (sub)graphs – diameter, density, connected components
		 - we can also compute metrics from the attributes (cost of a path if we have valued edges)
	- tasks
		- vertices – finding neighbors, degree
		- paths – finding shortest paths, cycles
		- graph – finding cliques
- visualization of graphs
	- we can even represent vertices as lines and edges as dots
	- hierarchical representation – no explicit edges, only hierarchy using enclosure
	- usual: node-link diagram
		- challenge – how to layout the nodes (“graph drawing”)
		- goal: optimize a quality metric (e.g. the number of links crossing, edge length, symmetry, angles, …)
		- for planar graphs – there can be no links crossing
		- sometimes, using attributes to compute the layout may be a good idea (e.g. time for linear layout)
- node-link layouts
	- linear layouts
		- even on a line, choosing the right order of the nodes is an interesting question
	- radial layouts
		- nodes on concentric circles
		- may be based on the selected node
			- it's better if the animation uses linear interpolation of polar coordinates
	- force-directed layout
		- attractive forces (links) and repulsive forces (nodes)
		- repulsion of nodes decreases with distance … $\frac1{d^2}$
		- attraction of two nodes connected by a link increases with distance … $d$
		- we need to compute the forces for all pairs of nodes
			- to get the final force of the node, we combine all the partial forces
		- problem: the initial random layout influences the final layout, there's no determinism
		- we can add constraints and generate a layout, which uses them
			- e.g. several nodes have to be on a line
			- Cola.js library
- node-link edges
	- edge-bundling
		- attractive/repulsive forces between segments of links → some links are bundled
			- parts of links going in the similar direction are bundled
			- visualization becomes more clear (edges cover smaller area of the chart)
		- very time consuming (quadratic number of edges, quadratic number of segment pairs)
		- another approach: computation in the pixel space
	- edge compression
		- power graph compression (one edge between sets of vertices instead of many edges between individual vertices)
		- there has to be a stopping condition for edge reduction
- adjacency matrix
	- vertices as rows and columns, edges as intersections
	- symmetrical for undirected graphs
	- we can represent all edges without overlapping or occlusion
	- hard to encode attributes of vertices – we can use the width of the line
	- patterns
		- central nodes – a lot of connections in one row/column
		- cliques – “squares”
			- if the rows/columns are in the correct order
			- → 1D layout problem, minimization of distances between vectors
			- we can use clustering
		- off-diagonal block pattern – kind of bipartite (sub)graph
		- bands pattern – “rings”
		- noise anti-pattern
			- hard to distinguish from badly ordered rows
		- bandwidth anti-pattern
			- if we sort the nodes in some special way (by their degree?)
			- it looks interesting but there's no interesting structure in the graph
	- Reorderable matrices (Bertin)
		- undirected bipartite graph → rectangular adjacency matrix
		- some reordering can be automatic, some can be manual
	- TableLens – spreadsheet with graphical visualization of attributes
	- for large graphs, node-link outperforms adjacency matrices only on tasks involving finding path
- trees
	- definition – DAG (?)
	- every vertex points to its parent (and stores other attributes)
	- tasks
		- find parent/children/siblings of a node
		- size/width/depth of a subtree
		- path to a node
	- layouts – node-link or nested
- trees: node-link
	- first approach
		- vertical coordinate corresponds to depth
		- to get horizontal coordinates, we start from the leaves and assign each leaf its coordinate (for parents, we can average their children or the leaves)
	- second approach
		- the same as first but in polar coordinates
	- collapsible subtrees
		- collapsed subtrees are represented by triangles (which corresponding width, height, and color)
		- SpaceTree
	- to get enough space, we may use hyperbolic geometry → we get infinite space (but infinitely small nodes at the edge of the circle)
	- it's probably a bad idea to use 3D for trees
- trees: nested layouts
	- TreeMap
	- nodes are rectangles, parents enclose their children (their subtrees)
		- edges correspond to the enclosure
	- if leaves have attributes (values) we can sum to get values for their parents, these attributes can correspond to the area (e.g. sizes of files)
		- simple implementation: we switch between splitting horizontally and vertically (slice and dice)
			- we still need to define traversal order
			- we have no control over aspect ratio (it's hard to compare areas of rectangles with too different aspect ratio)
	- how to make the hierarchy understandable?
		- we can use colors and text orientation
	- nested circles waste a lot of space but look nicer
	- can be combined with node-link → Elastic Hierarchies
